
Sat Jan 26 04:45:48 GMT 2019

inheritance chain.

inheritance hierarchy,

“is–a” rule

substitution principle.

substitution principle. That principle states that you can use a subclass object whenever the program expects a superclass object.

object variables are polymorphic.

In this case, the variables staff[0] and boss refer to the same object. However, staff[0] is considered to be only an Employee object by the compiler.

arrays of subclass references can be converted to arrays of superclass references without a cast.

To make sure no such corruption can occur, all arrays remember the element type with which they were created, and they monitor that only compatible references are stored into them.

overloading resolution.

If you define a method in a subclass that has the same signature as a superclass method, then you override that method.

when you override a method, you need to keep the return type compatible. A subclass may change the return type to a subtype of the original type.

covariant return types.

static binding.

the method is private, static, final, or a constructor, then the compiler knows exactly which method to call.

When the program runs and uses dynamic binding to call a method, then the virtual machine must call the version of the method that is appropriate for the actual type of the object to which x refers.

the virtual machine precomputes for each class a method table that lists all method signatures and the actual methods to be called.

Dynamic binding has a very important property: It makes programs extensible without the need for modifying existing code.

When you override a method, the subclass method must be at least as visible as the superclass method. In particular, if the superclass method is public, then the subclass method must also be declared as public.

2.3.1. Troubleshooting Hints

2.4. Using an Integrated Development Environment

2.4.1. Locating Compilation Errors

2.5. Running a Graphical Application

2.6. Building and Running Applets

most of the early hype about Java came from its ability to run applets inside a web browser.

Chapter 3. Fundamental Programming Structures in Java

3.1. A Simple Java Program

access modifier;

access modifier; these modifiers control the level of access other parts of a program have to this code.

Names must begin with a letter, and after that, they can have any combination of letters and digits.

You need to make the file name for the source code the same as the name of the public class,

it is remarkable that Sun made the bug reports and their resolutions available for anyone to scrutinize, long before Java was open source. The “bug parade” is a very useful resource for programmers.

If the main method exits normally, the Java program has the exit code 0, indicating successful completion. To terminate the program with a different exit code, use the System.exit method.

a variant of the println method with no parameters just prints a blank line. You invoke it with the call System.out.println();

System.out also has a print method that doesn’t add a newline character to the output.

3.2. Comments

a third kind of comment can be used to generate documentation automatically. This comment uses a /** to start and a */ to end.

3.3. Data Types

There are eight primitive types in Java.

3.3.1. Integer Types

In most situations, the int type is the most practical.

The byte and short types are mainly intended for specialized applications, such as low-level file handling, or for large arrays when storage space is at a premium.

Under Java, the ranges of the integer types do not depend on the machine on which you will be running the Java code.

Long integer numbers have a suffix L (for example, 4000000000L). Hexadecimal numbers have a prefix 0x (for example, 0xCAFE). Octal numbers have a prefix 0. For example, 010 is 8.

Starting with Java 7, you can write numbers in binary, with a prefix 0b.

Also starting with Java 7, you can add underscores to number literals, such as 1_000_000 (or 0b1111_0100_0010_0100_0000) to denote one million. The underscores are for human eyes only. The Java compiler simply removes them.

Note that Java does not have any unsigned types.

3.3.2. Floating-Point Types

Here, the type to choose in most applications is double.

Numbers of type float have a suffix F (for example, 3.14F). Floating-point numbers without an F suffix (such as 3.14) are always considered to be of type double. You can optionally supply the D suffix (for example, 3.14D).

You can specify floating-point literals in hexadecimal. For example, 0.125 = 2–3 can be written as 0x1.0p-3. In hexadecimal notation, you use a p, not an e, to denote the exponent.

Note that the mantissa is written in hexadecimal and the exponent in decimal. The base of the exponent is 2, not 10.

In particular, there are three special floating-point values to denote overflows and errors: • Positive infinity • Negative infinity • NaN (not a number) For example, the result of dividing a positive number by 0 is positive infinity. Computing 0/0 or the square root of a negative number yields NaN.

The constants Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, and Double.NaN (as well as corresponding Float constants) represent these special values,

the Double.isNaN method: if (Double.isNaN(x)) // check whether x is "not a number"

Floating-point numbers are not suitable for financial calculations in which roundoff errors cannot be tolerated.

If you need precise numerical computations without roundoff errors, use the BigDecimal class,

3.3.3. The char Type

3.3.3. The char Type The char type is used to describe individual characters. Most commonly, these will be character constants.

Unicode code units can be expressed as hexadecimal values that run from \u0000 to \uFFFF.

the \u escape sequences

there are several escape sequences for special characters, as shown in Table 3.3. You can use these escape sequences inside quoted character constants and strings, such as '\u2122' or "Hello\n". The \u escape sequence (but none of the other escape sequences) can even be used outside quoted character constants and strings.

A code point is a code value that is associated with a character in an encoding scheme. In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such as U+0041 for the code point of the Latin letter A. Unicode has code points that are grouped into 17 code planes. The first code plane, called the basic multilingual plane, consists of the “classic” Unicode characters with code points U+0000 to U+FFFF. Sixteen additional planes, with code points U+10000 to U+10FFFF, hold the supplementary characters.

A code point is a code value that is associated with a character in an encoding scheme.

In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such as U+0041 for the code point of the Latin letter A.

A code point is a code value that is associated with a character in an encoding scheme. In the Unicode standard, code points are written in hexadecimal and prefixed with U+, such as U+0041 for the code point of the Latin letter A. Unicode has code points that are grouped into 17 code planes. The first code plane, called the basic multilingual plane, consists of the “classic” Unicode characters with code points U+0000 to U+FFFF. Sixteen additional planes, with code points U+10000 to U+10FFFF, hold the supplementary characters.

The UTF-16 encoding represents all Unicode code points in a variable-length code. The characters in the basic multilingual plane are represented as 16-bit values, called code units. The supplementary characters are encoded as consecutive pairs of code units. Each of the values in such an encoding pair falls into a range of 2048 unused values of the basic multilingual plane, called the surrogates area (U+D800 to U+DBFF for the first code unit, U+DC00 to U+DFFF for the second code unit).

In Java, the char type describes a code unit in the UTF-16 encoding. Our strong recommendation is not to use the char type in your programs unless you are actually manipulating UTF-16 code units. You are almost always better off treating strings (which we will discuss in Section 3.6, “Strings,” on p. 64) as abstract data types. 3.3.4. The boolean Type

You cannot convert between integers and boolean values.

3.4. Variables

Note that the terms “letter” and “digit” are much broader in Java than in most languages. A letter is defined as 'A'–'Z', 'a'–'z', '_', '$', or any Unicode character that denotes a letter in a language.

If you are really curious as to what Unicode characters are “letters” as far as Java is concerned, you can use the isJavaIdentifierStart and isJavaIdentifierPart methods in the Character class to check.

Even though $ is a valid Java letter, you should not use it in your own code. It is intended for names that are generated by the Java compiler and other tools.

3.4.1. Initializing Variables

in Java you can put declarations anywhere in your code.

In Java, it is considered good style to declare variables as closely as possible to the point where they are first used.

3.4.2. Constants In Java, you use the keyword final to denote a constant.

class constants. Set up a class constant with the keywords static final.

3.5. Operators

Note that integer division by 0 raises an exception, whereas floating-point division by 0 yields an infinite or NaN result.

methods tagged with the strictfp keyword must use strict floating-point operations that yield reproducible results.

methods tagged with the strictfp keyword must use strict floating-point operations that yield reproducible results. For example, you can tag main as public static strictfp void main(String[] args) Then all instructions inside the main method will use strict floating-point computations. If you tag a class as strictfp, then all of its methods must use strict floating-point computations.

3.5.1. Increment and Decrement Operators

3.5.2. Relational and boolean Operators

3.5.3. Bitwise Operators

a >>> operator fills the top bits with zero, unlike >> which extends the sign bit into the top bits. There is no <<< operator.

The right-hand side argument of the shift operators is reduced modulo 32 (unless the left-hand side is a long, in which case the right-hand side is reduced modulo 64). For example, the value of 1 << 35 is the same as 1 << 3 or 8.

3.5.4. Mathematical Functions and Constants

You can avoid the Math prefix for the mathematical methods and constants by adding the following line to the top of your source file: import static java.lang.Math.*;

If completely predictable results are more important than fast performance, use the StrictMath class instead. It implements the algorithms from the “Freely Distributable Math Library” fdlibm, guaranteeing identical results on all platforms.

3.5.5. Conversions between Numeric Types

Figure 3.1. Legal conversions between numeric types

When two values are combined with a binary operator (such as n + f where n is an integer and f is a floating-point value), both operands are converted to a common type before the operation is carried out. • If either of the operands is of type double, the other one will be converted to a double. • Otherwise, if either of the operands is of type float, the other one will be converted to a float. • Otherwise, if either of the operands is of type long, the other one will be converted to a long. • Otherwise, both operands will be converted to an int.

3.5.6. Casts

If you want to round a floating-point number to the nearest integer (which in most cases is the more useful operation), use the Math.round method: double x = 9.997; int nx = (int) Math.round(x);

You still need to use the cast (int) when you call round.

If you try to cast a number of one type to another that is out of the range for the target type, the result will be a truncated number that has a different value. For example, (byte) 300 is actually 44.

3.5.7. Parentheses and Operator Hierarchy

Table 3.4 on the following page shows the precedence of operators.

3.5.8. Enumerated Types

A variable of type Size can hold only one of the values listed in the type declaration, or the special value null that indicates that the variable is not set to any value at all.

3.6. Strings Conceptually, Java strings are sequences of Unicode characters.

Java does not have a built-in string type. Instead, the standard Java library contains a predefined class called, naturally enough, String.

3.6.1. Substrings

The second parameter of substring is the first position that you do not want to copy.

The string s.substring(a, b) always has length b - a.

3.6.2. Concatenation Java,

allows you to use + to join (concatenate) two strings.

When you concatenate a string with a value that is not a string, the latter is converted to a string.

3.6.3. Strings Are Immutable The String class gives no methods that let you change a character in an existing string.

How are we going to modify the string?

the documentation refers to the objects of the String class as immutable.

But immutable strings have one great advantage: The compiler can arrange that strings are shared.

If you copy a string variable, both the original and the copy share the same characters.

3.6.4. Testing Strings for Equality To test whether two strings are equal, use the equals method.

use the equalsIgnoreCase method.

Do not use the == operator to test whether two strings are equal! It only determines whether or not the strings are stored in the same location.

The Java method compareTo is the exact analog to strcmp.

3.6.5. Empty and Null Strings The empty string "" is a string of length 0. You can test whether a string is empty by calling if (str.length() == 0) or if (str.equals(""))

a String variable can also hold a special value, called null, that indicates that no object is currently associated with the variable.

3.6.5. Code Points and Code Units

the char data type is a code unit for representing Unicode code points in the UTF-16 encoding. The most commonly used Unicode characters can be represented with a single code unit. The supplementary characters require a pair of code units. The length method yields the number of code units required for a given string in the UTF-16 encoding.

To get the true length—that is, the number of code points—call int cpCount = greeting.codePointCount(0, greeting.length()); The call s.charAt(n) returns the code unit at position n, where n is between 0 and s.length() – 1.

To get at the ith code point, use the statements

int index =

greeting.offsetByCodePoints(0, i); int cp = greeting.codePointAt(index);

int cp = sentence.codePointAt(i); if

i--; if

3.6.6. The String API

3.6.7. Reading the Online API Documentation

3.6.8. Building Strings

First, construct an empty string builder: StringBuilder builder = new StringBuilder();

Each time you need to add another part, call the append method.

Sun Jan 27 05:37:47 GMT 2019

When you are done building the string, call the toString method. You will get a String object with the character sequence contained in the builder. String completedString = builder.toString();

The StringBuilder class was introduced in JDK 5.0. Its predecessor, StringBuffer, is slightly less efficient, but it allows multiple threads to add or remove characters. If all string editing happens in a single thread (which is usually the case), you should use StringBuilder instead. The APIs of both classes are identical.

3.7. Input and Output

3.7.1. Reading Input

To read console input, you first construct a Scanner that is attached to System.in: Scanner in = new Scanner(System.in);

How to read console input?

the nextLine method reads a line of input.

To read a single word (delimited by whitespace), call String firstName = in.next(); To read an integer, use the nextInt method.

the nextDouble method reads the next floating-point number.

The Scanner class is defined in the java.util package. Whenever you use a class that is not defined in the basic java.lang package, you need to use an import directive.

The Scanner class is not suitable for reading a password from a console since the input is plainly visible to anyone.

To read a password, use the following code:

Console cons = System.console(); String username = cons.readLine("User name: "); char[] passwd = cons.readPassword("Password:

java.util.Scanner 5.0

3.7.2. Formatting Output

Fortunately, Java SE 5.0 brought back the venerable printf method from the C library.

Table 3.5. Conversions for printf

In addition, you can specify flags that control the appearance of the formatted output. Table 3.6 shows all flags.

You can use the s conversion to format arbitrary objects. If an arbitrary object implements the Formattable interface, the object’s formatTo method is invoked. Otherwise, the toString method is invoked to turn the object into a string.

You can use the static String.format method to create a formatted string without printing it: String message = String.format("Hello, %s. Next year, you'll be %d", name, age);

the date and time formatting options of the printf method. Use a two-letter format, starting with t and ending in one of the letters of Table 3.7;

Table 3.7. Date and Time Conversion Characters

It would be a bit silly if you had to supply the date multiple times to format each part.

What to do to format some parts of a date?

Figure 3.6 shows a syntax diagram for format specifiers.

A number of the formatting rules are locale-specific. For example, in Germany, the group separator is a period, not a comma, and Monday is formatted as Montag.

3.7.3. File Input and Output To read from a file, construct a Scanner object like this:

If the file name contains backslashes,

To write to a file, construct a PrintWriter object. In the constructor, simply supply the file name:

When you specify a relative file name,

What happens when you specify a relative file name?

If you construct a Scanner with a file that does not exist or a PrintWriter with a file name that cannot be created, an exception occurs.

When you launch a program from a command shell, you can use the redirection syntax of your shell and attach any file to System.in and System.out:

java.util.Scanner 5.0

java.io.PrintWriter 1.1

java.nio.file.Paths 7

3.8. Control Flow

3.8.1. Block Scope

A block or compound statement is any number of simple Java statements surrounded by a pair of braces.

However, you may not declare identically named variables in two nested blocks.

3.8.2. Conditional Statements

3.8.3. Loops

3.8.4. Determinate Loops

3.8.5. Multiple Selections—The switch Statement

If you like the switch statement better than we do, consider compiling your code with the -Xlint:fallthrough option, like this: javac -Xlint:fallthrough Test.java

If you actually want to use the fallthrough behavior, tag the surrounding method with the annotation @SuppressWarnings("fallthrough"). Then no warnings will

A case label can be

What can be used as a case label?

3.8.6. Statements That Break Control Flow

for example, the famous article of Donald Knuth called “Structured Programming with goto statements”).

The Java designers agreed and even added a new statement, the labeled break, to support this programming style.

Unlike C++, Java also offers a labeled break statement that lets you break out of multiple nested loops.

Notice that the label must precede the outermost loop out of which you want to break. It also must be followed by a colon.

As with any use of the break statement, you then need to test whether the loop exited normally or as a result of a break.

Curiously, you can apply a label to any statement, even an if statement or a block statement, like this: label: {   . . .   if (condition) break label; // exits block   . . . } // jumps here when the break statement executes

There is also a labeled form of the continue statement that jumps to the header of the loop with the matching label.

3.9. Big Numbers

a couple of handy classes in the java.math package: BigInteger and BigDecimal.

you can turn to a couple of handy classes in the java.math package: BigInteger and BigDecimal. These are classes for manipulating numbers with an arbitrarily long sequence of digits. The BigInteger class implements arbitrary-precision integer arithmetic, and BigDecimal does the same for floating-point numbers.

a couple of handy classes in the java.math package: BigInteger and BigDecimal.

What are BigInteger and BigDecimal for?

Use the static valueOf method to turn an ordinary number into a big number: BigInteger a = BigInteger.valueOf(100);

What's the method we use to turn an ordinary number into a big number?

you cannot use the familiar mathematical operators such as + and * to combine big numbers. Instead, you must use methods such as add and multiply in the big number

java.math.BigInteger 1.1

java.math.BigDecimal 1.1

3.10. Arrays

The array length need not be a constant: new int[n] creates an array of length n.

When you create an array of numbers, all elements are initialized with zero. Arrays of boolean are initialized with false. Arrays of objects are initialized with the special value null, which indicates that they do not (yet) hold any objects.

What's an array initialized to by default at the time of its creation?

3.10.1. The “for each” Loop

The enhanced for loop for (variable : collection) statement sets the given variable to each element of the collection and then executes the statement

The collection expression must be an array or an object of a class that implements the Iterable interface, such as ArrayList.

The loop variable of the “for each” loop traverses the elements of the array, not the index values.

The call Arrays.toString(a) returns a string containing the array elements, enclosed in brackets and separated by commas, such as "[2, 3, 5, 7, 11, 13]". To print the array, simply call System.out.println(Arrays.toString(a));

3.10.2. Array Initializers and Anonymous Arrays

Java has a shorthand to create an array object and supply initial values at the same time.

What's the shorthand to create an array object?

You can even initialize an anonymous array: new int[] { 17, 19, 23, 29, 31, 37 }

You can use this syntax to reinitialize an array without creating a new variable. For example, smallPrimes = new int[] { 17, 19, 23, 29, 31, 37 };

It is legal to have arrays of length 0. Such an array can be useful if you write a method that computes an array result and the result happens to be empty. Construct an array of length 0 as new elementType[0] Note that an array of length 0 is not the same as null.

3.10.3. Array Copying

You can copy one array variable into another, but then both variables refer to the same array:

What happens when you copy one array variable into another?

If you actually want to copy all values of one array into a new array, you use the copyOf method in the Arrays class: int[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckyNumbers.length);

What method is used to copy all values of one array into a new array?

A common use of this method is to increase the size of an array: luckyNumbers = Arrays.copyOf(luckyNumbers, 2 * luckyNumbers.length);

3.10.4. Command-Line Parameters

Fri Feb 01 23:32:39 GMT 2019

Sat Feb 02 00:28:51 GMT 2019

In the main method of a Java program, the name of the program is not stored in the args array.

3.10.5. Array Sorting

To sort an array of numbers, you can use one of the sort methods in the Arrays class:

Arrays.sort(a)

The Math.random method returns a random floating-point number that is between 0 (inclusive) and 1 (exclusive).

java.util.Arrays 1.2

3.10.6. Multidimensional Arrays

In other cases, if you know the array elements, you can use a shorthand notation for initializing a multidimensional array without a call to new.

To print out a quick-and-dirty list of the elements of a two-dimensional array, call System.out.println(Arrays.deepToString(a));

3.10.7. Ragged Arrays

Java has no multidimensional arrays at all, only one-dimensional arrays. Multidimensional arrays are faked as “arrays of arrays.”

It is also easy to make “ragged” arrays—that is, arrays in which different rows have different lengths.

Instead, an array of ten pointers is allocated:

In C++, the Java declaration double[][] balances = new double[10][6]; // Java is not the same as double balances[10][6]; // C++ or even double (*balances)[6] = new double[10][6]; // C++ Instead, an array of ten pointers is allocated: double** balances = new double*[10]; // C++ Then, each element in the pointer array is filled with an array of six numbers: for (i = 0; i < 10; i++)    balances[i] = new double[6]; Mercifully, this loop is automatic when you ask for a new double[10][6]. When you want ragged arrays, you allocate the row arrays separately.

Chapter 4. Objects and Classes

4.1. Introduction to Object-Oriented Programming

Algorithms + Data Structures = Programs

4.1.1. Classes

A class is the template or blueprint from which objects are made.

Encapsulation (sometimes called information hiding) is a key concept in working with objects.

The bits of data in an object are called its instance fields, and the procedures that operate on the data are called its methods.

What're instance fields and methods?

The set of those values is the current state of the object. Whenever you invoke a method on an object, its state may change.

What's the state of an object?

Programs should interact with object data only through the object’s methods.

Java, in fact, comes with a “cosmic superclass” called Object. All other classes extend this class.

4.1.2. Objects

three key characteristics

What're the three key characteristics of objects?

Notice that the individual objects that are instances of a class always differ in their identity and usually differ in their state.

4.1.3. Identifying Classes

A simple rule of thumb in identifying classes is to look for nouns in the problem analysis. Methods, on the other hand, correspond to verbs.

4.1.4. Relationships between Classes

The most common relationships between classes are • Dependence (“uses–a”) • Aggregation (“has–a”) • Inheritance (“is–a”)

What're the most common rel bt classes?

Try to minimize the number of classes that depend on each other.

In software engineering terminology, you want to minimize the coupling between classes.

Many programmers use the UML (Unified Modeling Language) notation to draw class diagrams that describe the relationships between classes.

Table 4.1. UML notation for class relationships

4.2. Using Predefined Classes

4.2.1. Objects and Object Variables

use constructors to construct new instances. A constructor is a special method whose purpose is to construct and initialize objects.

What's a constructor?

Constructors always have the same name as the class name.

It is important to realize that the variable deadline is not an object and, in fact, does not even refer to an object yet.

What's the diff btwn an object var and an obj?

The return value of the new operator is also a reference.

What is the ret val of a new op?

You can explicitly set an object variable to null to indicate that it currently refers to no object.

Local variables are not automatically initialized to null. You must initialize them, either by calling new or by setting them to null.

But in C++ there are no null references, and references cannot be assigned. You should think of Java object variables as analogous to object pointers in C++.

The equivalent of the Java null reference is the C++ NULL pointer. All Java objects live on the heap. When an object contains another object variable, it contains just a pointer to yet another heap object.

In Java, you must use the clone method to get a complete copy of an object.

4.2.2. The GregorianCalendar Class of the Java Library

An instance of the Date class has a state, namely a particular point in time.

Therefore, the standard Java library contains two separate classes: the Date class, which represents a point in time, and the GregorianCalendar class, which expresses dates in the familiar calendar notation.

High ..., low coupling

The Date class has only a small number of methods that allow you to compare two points in time. For example, the before and after methods tell you if one point in time comes before or after another:

if (today.before(birthday))    System.out.println("Still time to shop for a gift.");

new GregorianCalendar() constructs a new object that represents the date and time at which the object was constructed.

You can construct a calendar object for midnight on a specific date by supplying year, month, and day: new GregorianCalendar(1999, 11, 31)

Somewhat curiously, the months are counted from 0.

For greater clarity, there are constants like Calendar.DECEMBER: new GregorianCalendar(1999, Calendar.DECEMBER, 31) You can also set the time: new GregorianCalendar(1999, Calendar.DECEMBER, 31, 23, 59, 59) Of course, you will usually want to store the constructed object in an object variable: GregorianCalendar deadline = new GregorianCalendar(. . .);

4.2.3. Mutator and Accessor Methods

What's the job of a calendar?

What merhod to use to query the date, weekday, month, or year of a certain point in time? And how to use it?

To change the state, call the set method:

There is also a convenience method to set the year, month, and day with a single call:

Finally, you can add a number of days, weeks, months, and so on, to a given calendar object:

If you add a negative number, then the calendar is moved backwards.

What're mutator and accessor methods?

What methods are particularly useful for converting btw the Date class and the Gregorian class?

java.util.GregorianCalendar 1.1

java.text.DateFormatSymbols 1.1

4.3. Defining Your Own Classes

4.3.1. An Employee Class

the name of the file must match the name of the public class. You can only have one public class in a source file, but you can have any number of nonpublic classes.

4.3.2. Use of Multiple Source Files

you can think of the Java compiler as having the make functionality already built in.

4.3.3. Dissecting the Employee Class

The keyword public means that any method in any class can call the method.

What does the keyword public placed b4 a method header mean?

What does the key word private mean?

Classes will often contain instance fields of class type.

4.3.4. First Steps with Constructors

Be careful not to introduce local variables with the same names as the instance fields.

4.3.5. Implicit and Explicit Parameters

What is the implicit param and what are the explicit param(s) in a method?

In Java, all methods are defined inside the class itself. This does not make them inline. Finding opportunities for inline replacement is the job of the Java virtual machine.

4.3.6. Benefits of Encapsulation

Mutator methods can perform error checking, whereas code that simply assigns to a field may not go into the trouble.

Be careful not to write accessor methods that return references to mutable objects.

If you need to return a reference to a mutable object, you should clone it first. A clone is an exact copy of an object stored in a new location.

What should be done to return a mutable object?

As a rule of thumb, always use clone whenever you need to return a copy of a mutable data field.

4.3.7. Class-Based Access Privileges

What many people find surprising is that a method can access the private data of all objects of its class.

4.3.8. Private Methods

While most methods are public, private methods are useful in certain circumstances.

What're helper method?

4.3.9. Final Instance Fields

By making a method private, you are under no obligation to keep it available if you change your implementation.

The point is that as long as the method is private, the designers of the class can be assured that it is never used outside the other class, so they can simply drop it. If a method is public, you cannot simply drop it because other code might rely on it.

4.3.9. Final Instance Fields

You can define an instance field as final. Such a field must be initialized when the object is constructed.

Afterwards, the field may not be modified again.

What's s final modifier useful for?

For mutable classes, the final modifier is likely to confuse the reader. For example, private final Date hiredate;

For mutable classes, the final modifier is likely to confuse the reader. For example, private final Date hiredate; merely means that the object reference stored in the hiredate variable doesn’t get changed after the object is constructed. That does not mean that the hiredate object is constant.

4.4. Static Fields and Methods

4.4.1. Static Fields

What happens when a field is defined static?

4.4.2. Static Constants

Static variables are quite rare. However, static constants are more common.

Another static constant that you have used many times is System.out.

If you look at the System class, you will notice a method setOut that sets System.out to a different stream. You may wonder how that method can change the value of a final variable. However, the setOut method is a native method, not implemented in the Java programming language. Native methods can bypass the access control mechanisms of the Java language.

4.4.3. Static Methods

What're static methods?

However, static methods can access the static fields in their class.

What can static methods access in their class?

What is needed to call a static method? 

Use static methods in two situations:

4.4.4. Factory Methods

The NumberFormat class uses factory methods that yield formatter objects for various styles.

4.4.5. The main Method

Note that you can call static methods without having any objects.

Every class can have a main method. That is a handy trick for unit-testing of classes.

4.5. Method Parameters

call by value means that

call by reference means that

The Java programming language always uses call by value.

What is meant by call by value in Java?

You have seen that it is impossible for a method to change a primitive type parameter. The situation is different for object parameters.

Here is a summary of what you can and cannot do with method parameters in Java:

4.6. Object Construction

4.6.1. Overloading

What's overloading?

4.6.2. Default Field Initialization

Note
What happens if you don't set a field explicitly in a constructor?

You must always explicitly initialize local variables in a method.

4.6.3. The Constructor with No Arguments

Many classes contain a constructor with no arguments that creates an object whose state is set to an appropriate default.

What happens if a class is not explicitly given a constructor?

If a class supplies at least one constructor but does not supply a no-argument constructor, it is illegal to construct objects without supplying arguments.

If you write your class with even a single constructor of your own and you want the users of your class to have the ability to create an instance by a call to new ClassName() then you must provide a no-argument constructor.

4.6.4. Explicit Field Initialization

It is always a good idea to make sure that, regardless of the constructor call, every instance field is set to something meaningful.

You can simply assign a value to any field in the class definition. For example: class Employee {    private String name = "";    . . . }

This syntax is particularly useful if all constructors of a class need to set a particular instance field to the same value.

The initialization value doesn’t have to be a constant value.

4.6.5. Parameter Names

4.6.6. Calling Another Constructor

What's the sec meaning of the this keyword?

Using the this keyword in this manner is useful—you only need to write common construction code once.

4.6.7. Initialization Blocks

You have already seen two ways to initialize a data field:

Note
There is a third mechanism in Java, called an

In this example, the id field is initialized in the object initialization block, no matter which constructor is used to construct an object.

However, to avoid circular definitions, it is not legal to read from fields that are only initialized later.

Therefore, we suggest that you always place initialization blocks after the field definitions.

Here is what happens in detail when a constructor is called:

Whar are the ways for init a static field?

Place the code inside a block and tag it with the keyword static.

Note
// static initialization block static {    Random generator = new Random();    nextId = generator.nextInt(10000); }

java.util.Random 1.0

4.6.8. Object Destruction and the finalize Method

Of course, some objects utilize a resource other than memory, such as a file or a handle to another object that uses system resources. In this case, it is important that the resource be reclaimed and recycled when it is no longer needed.

You can add a finalize method to any class. The finalize method will be called before the garbage collector sweeps away the object. In practice, do not rely on the finalize method for recycling any resources that are in short supply—you simply cannot know when this method will be called.

The method call

System.runFinalizersOnExit(true) guarantees that finalizer methods are called before Java shuts down.

If a resource needs to be closed as soon as you have finished using it, you need to manage it manually. Supply a close method that does the necessary cleanup, and call it when you are done with the object.

4.7. Packages

What's a package made up of and what's it used for?

hierarchical packages.

All standard Java packages are inside the java and javax package hierarchies.

The main reason for using packages is to guarantee the uniqueness of class names.

What's the main reason for using packages?

What to use to ensure a unique package name?

From the point of view of the compiler, there is absolutely no relationship between nested packages. For example, the packages java.util and java.util.jar have nothing to do with each other. Each is its own independent collection of classes.

4.7.1. Class Importation

Note
A class can use all classes from its own package and all public classes from other packages.

What're the two ways to use public classes from another packages?

What're the two ways to use public classes from another package?

Where do we put an import statement?

In Eclipse, you can select the menu option Source -> Organize Imports. Package statements such as import java.util.*; are automatically expanded into a list of specific imports

The only time that you need to pay attention to packages is when you have a name conflict.

You can solve this problem by adding a specific import statement: import java.util.*; import java.sql.*; import java.util.Date; What if you really need both Date classes? Then you need to use the full package name with every class name.

4.7.2. Static Imports

What's the use of static imports?

import static java.lang.System.*;

You can also import a specific method or field: import static java.lang.System.out;

4.7.3. Addition of a Class into a Package

How to put a class in a package?

Note
What happens if we don't put a package statement in the same file?

Place source files into a subdirectory that matches the full package name.

Note
The compiler does not check the directory structure when it compiles source files.

4.7.4. Package Scope

If neither public nor private is specified for a class, a var or a method, what will be the access feature of the entity?

For classes, this is a reasonable default. However, for variables, this was an unfortunate choice. Variables must explicitly be marked private, or they will default to being package-visible.

4.8. The Class Path

Class files can also be stored in a JAR (Java archive) file.

What does a jar file contain?

Note
To share classes among programs, you need to do the following:

This class path contains

Starting with Java SE 6, you can specify a wildcard for a JAR file directory, like this:

The javac compiler always looks for files in the current directory, but the java virtual machine launcher only looks into the current directory if the “.” directory is on the class path. If you have no class path set, this is not a problem—the default class path consists of the “.” directory. But if you have set the class path and forgot to include the “.” directory, your programs will compile without error, but they won’t run.

If you refer to a class without specifying its package, the compiler first needs to find out the package that contains the class. It consults all import directives as possible sources for the class.

The compiler goes one step further. It looks at the source files to see if the source is newer than the class file. If so, the source file is recompiled automatically.

4.8.1. Setting the Class Path

It is best to specify the class path with the -classpath (or -cp) option:

Note
Some people recommend to set the CLASSPATH environment variable permanently. This is generally a bad idea. People forget the global setting, and are surprised when their classes are not loaded properly.

Some people recommend to bypass the class path altogether, by dropping all JAR files into the jre/lib/ext directory. That is truly bad advice, for two reasons.

4.9. Documentation Comments The JDK contains a very useful tool, called javadoc, that generates HTML documentation from your source files.

If you add comments that start with the special delimiter /** to your source code, you too can easily produce professional looking documentation.

4.9.1. Comment Insertion The javadoc utility extracts information for the following items: • Packages • Public classes and interfaces • Public and protected fields • Public and protected constructors and methods

Each comment is placed immediately above the feature it describes. A comment starts with a /** and ends with a */.

Note
Each /** . . . */ documentation comment contains free-form text followed by tags. A tag starts with an @, such as @author or @param.

A tag starts with

Note
The first sentence of the free-form text should be a

In the free-form text, you can use HTML modifiers

You should, however, stay away from headings <h1> or rules <hr> because they can interfere with the formatting of the document.

If your comments contain links to other files such as images

4.9.2. Class Comments

The class comment must be placed after any import statements, directly before the class definition.

4.9.3. Method Comments

Each method comment must immediately precede the method that it describes. In addition to the general-purpose tags, you can use the following tags:

@param variable description

• @param variable description

• @return description

• @throws class description

4.9.4. Field Comments

You only need to document public fields—generally that means static constants.

4.9.5. General Comments

The following tags can be used in class documentation comments:

• @author name

• @version text

The following tags can be used in all documentation comments:

• @since text

• @deprecated text

You can use hyperlinks to other relevant parts of the javadoc documentation, or to external documents, with the @see and @link tags.

4.9.6. Package and Overview Comments

to generate package comments, you need to add a separate file in each package directory. You have two choices:

Note
4.9.7. Comment Extraction

Another useful option is -link, to include hyperlinks to standard classes. For example, if you use the command

Note
Another useful option is -link, to include hyperlinks to standard classes.

If you use the -linksource option, each source file is converted to HTML (without color coding, but with line numbers), and each class and method name turns into a hyperlink to the source.

4.10. Class Design Hints

some hints that will make your classes more acceptable in well-mannered OOP circles.

1. Always keep data private.

Note
2. Always initialize data.

3. Don’t use too many basic types in a class.

4. Not all fields need individual field accessors and mutators.

6. Break up classes that have too many responsibilities.

7. Make the names of your classes and methods reflect their responsibilities.

Sun Feb 10 10:28:32 GMT 2019

Chapter 5. Inheritance

This chapter also covers reflection, the ability to find out more about classes and their properties in a running program.

5.1. Classes, Superclasses, and Subclasses

All inheritance in Java is public inheritance; there is no analog to the C++ features of private and protected inheritance.

The existing class is called

The new class is called

When defining a subclass by extending its superclass, you only need to indicate

When designing classes, you place

supply a new method to override the superclass method:

In what situation a new method needs to override the one of the same name in the super class?

The getSalary method of the Manager class has no direct access to the private fields of the superclass.

Only the methods of the Employee class have access to the private fields. If the Manager methods want to access those private fields, they have to do what every other method does—use

We need to indicate that we want to call the getSalary method of the Employee super-class, not the current class. You use the special keyword

for this purpose. The call

calls the getSalary method of the Employee class.

super is not a reference to an object. For example, you cannot assign the value super to another object variable. Instead, super is a special keyword that

As you saw, a subclass can add fields, and it can add methods or override the methods of the superclass.

What does the constructor look like in a subclass?

The call using super must be the first statement in the constructor for the subclass.

If the subclass constructor does not call a superclass constructor explicitly,

If the superclass does not have a no-argument constructor and the subclass constructor does not call another superclass constructor explicitly,

then again what happens?

Recall that the this keyword has two meanings:

Likewise, the super keyword has two meanings:

When used to invoke constructors, the this and super keywords are closely related.

What's in common?

What's polymorphism?

What's dynamic binding?

In Java, you do not need to declare a method as virtual. Dynamic binding is the default behavior. If you do not want a method to be virtual, you tag it as

5.1.1. Inheritance Hierarchies

is called an inheritance hierarchy,

is its inheritance chain.

There is usually more than one chain of descent from a distant ancestor class.

Java does not support multiple inheritance.

5.1.2. Polymorphism

The “is–a” rule states that every object of the subclass is an object of the superclass.

substitution principle. That principle states that

In the Java programming language, object variables are polymorphic.

For example, you can assign a subclass object to

In Java, arrays of subclass references can be converted to arrays of superclass references without a cast.

To make sure no such corruption can occur, all arrays remember the

5.1.3. Dynamic Binding

It is important to understand what happens when a method call is applied to an object. Here are the details:

1. The compiler looks at the declared type of the object and the method name.

2. Next, the compiler determines the types of the parameters that are supplied in the method call.

This process is called overloading resolution.

However, when you override a method, you need to keep the return type compatible. A subclass may change the return type to a subtype of the original type.

3. If the method is private, static, final, or a constructor, then the compiler knows exactly which method to call.

This is called static binding.

4. When the program runs and uses dynamic binding to call a method, then the virtual machine must call the version of the method that is appropriate for the actual type of the object to which x refers.

Dynamic binding has a very important property: It makes programs extensible without the need for modifying existing code.

When you override a method, the subclass method must be at least as visible as the superclass method. In particular, if the superclass method is public, then the subclass method must also be declared as public.

5.1.4. Preventing Inheritance: Final Classes and Methods

Classes that cannot be extended are called final classes, and you use the final modifier in the definition of the class to indicate this.

Classes that cannot be extended are called

and you use the

modifier in the definition of the class to indicate this.

You can also make a specific method in a class

If you do this, then no subclass can override that method.

if a class is declared final, only the methods, not the fields, are automatically final.

There is only one good reason to make a method or class final:

If a method is not overridden, and it is short, then a compiler can optimize the method call away—a

If a method is not overridden, and it is short, then a compiler can optimize the method call away—a process

the just-in-time compiler in the virtual machine

knows exactly which classes extend a given class, and it can check whether any class actually overrides a given method.

5.1.5. Casting

To actually make a cast of an object reference, use a syntax similar to

There is only one reason why you would want to make a cast—to

As you know, in Java every object variable has a type. The type describes

The compiler checks that you do not promise too much when you store a value in a variable.

If you assign a super-class reference to a subclass variable, you are promising more. Then you must use a cast so that your promise can be checked at runtime.

What happens if you try to cast down an inheritance chain and you are “lying” about what an object contains?

Thus, it is good programming practice to find out whether a cast will succeed before attempting it. Simply use the

operator.

the compiler will not let you make a cast if there is no chance for the cast to succeed.

• You can cast only within an inheritance hierarchy. • Use instanceof to check before casting from a superclass to a subclass.

Actually, converting the type of an object by performing a cast is not usually a good idea.

Remember, it takes only one uncaught ClassCastException to terminate your program. In general, it is best to minimize the use of casts and the instanceof operator.

5.1.6. Abstract Classes

public abstract String getDescription();    // no implementation required For added clarity, a class with one or more abstract methods must itself be declared abstract. abstract class Person {  . . .    public abstract String getDescription(); } In addition to abstract methods, abstract classes can have fields and concrete methods.

You should always move common fields and methods (whether abstract or not) to the superclass (whether abstract or not).

Abstract methods act as placeholders for methods that are implemented in the subclasses.

When you extend an abstract class, you have two choices.

A class can even be declared as abstract even though it has no abstract methods.

Abstract classes cannot be instantiated. That is, if a class is declared as abstract, no objects of that class can be created.

Note that you can still create object variables of an abstract class, but such a variable must refer to an object of a nonabstract subclass.

the variable p never refers to a Person object because it is impossible to construct an object of the abstract Person class. The variable p always refers to an object of a concrete subclass such as Employee or Student.

Could you have omitted the abstract method altogether from the Person superclass, simply defining the getDescription methods in the Employee and Student subclasses?

What will happen then?

Abstract methods are an important concept in the Java programming language. You will encounter them most commonly inside interfaces.

5.1.7. Protected Access

In what case do you declare a class feature as protected?

However, the Manager class methods can peek inside the hireDay field of Manager objects only, not of other Employee objects.

In practice, use protected fields with caution.

Protected methods make more sense. A class may declare a method as protected if it is tricky to use.

This indicates that

As it happens, protected features in Java are visible to all subclasses as well as to all other classes in the same package.

Here is a summary of the four access modifiers in Java that control visibility:

1. Visible to the class only

2. Visible to the world

3. Visible to the package and all subclasses

4. Visible to the package—the

5.2. Object: The Cosmic Superclass

The ultimate superclass Object is taken for granted if no superclass is explicitly mentioned.

You can use a variable of type Object to refer to objects of any type:

Of course, a variable of type Object is only useful as a generic holder for arbitrary values. To do anything specific with the value, you need to

5.2.1. The equals Method

The equals method,

determines whether

However, you will often want to implement state-based equality testing, in which

The

method returns the class of an object—we

To guard against the possibility that name or hireDay are null, use the Objects.equals method. The call Objects.equals(a, b) returns

When you define the equals method for a subclass, first call

If that test doesn’t pass, then

If

are equal, then you are ready to compare the instance fields of the subclass.

5.2.2. Equality Testing and Inheritance

How should the equals method behave if the implicit and explicit parameters don’t belong to the same class?

Here is a recipe for writing the perfect equals method:

If you have fields of array type, you can use the

to check that the corresponding array elements are equal.

This method declares the explicit parameter type as Employee. As a result, it does not override the equals method of the Object class but defines a completely unrelated method.

You can protect yourself against this type of error by

java.util.Arrays 1.2 • static boolean equals(type[] a, type[] b) 5.0

java.util.Objects 7

5.2.3. The hashCode Method

A hash code is

The hashCode method is defined in the Object class.

Note that the strings s and t have the same hash code because, for strings, the hash codes are derived from their contents.

If you redefine the equals method, you will also need to redefine the hashCode method for objects that users might insert into a hash table.

The hashCode method should return an integer (which can be negative). Just combine the hash codes of the instance fields so that the hash codes for different objects are likely to be widely scattered.

However, as of Java 7, there are two improvements you can make. First, it is better to use the null-safe method

It returns

Even better, when you need to combine multiple hash values, call

Your definitions of equals and hashCode must be compatible: If x.equals(y) is true, then x.hashCode() must return the same value as y.hashCode().

For example, if you define Employee.equals to compare employee IDs, then the hashCode method needs to hash the IDs, not employee names or memory addresses.

If you have fields of an array type, you can use the static Arrays.hashCode method to compute a hash code composed of the hash codes of the array elements.

Note
java.lang.Object 1.0

• int hashCode()

java.lang.Objects 7

• int hash(Object... objects)

• static int hashCode(Object a)

java.util.Arrays 1.2

• static int hashCode(type[] a) 5.0

5.2.4. The toString Method

Another important method in Object is the toString method that returns

Most (but not all) toString methods follow this format:

Instead of hardwiring the class name into the toString method, call

Such toString method will also work for subclasses. Of course, the subclass programmer should define its own toString method and add the subclass fields.

Such toString method will also work for subclasses. Of course, the subclass programmer should define

If the superclass uses getClass().getName(), then the subclass can

The Object class defines the toString method to print the

Annoyingly, arrays inherit the toString method from Object, with the added twist that the array type is printed in an archaic format.

The remedy is to call

To correctly print multidimensional arrays

Note
use

The toString method is a great tool for

We strongly recommend that you add a toString method to each class that you write.

java.lang.Object 1.0

• Class getClass()

>• boolean equals(Object otherObject)

• String toString()

Note
java.lang.Class 1.0

• String getName()

• Class getSuperclass()

5.3. Generic Array Lists

The ArrayList class

ArrayList is a generic class with a type parameter. To specify the type of the element objects that the array list holds,

ArrayList is a generic class with a type parameter. To specify the type of the element objects that the array list holds, you

As of Java 7, you can omit the type parameter on the right-hand side:

the “diamond” syntax

Before Java SE 5.0, there were no generic classes. Instead, there was a single ArrayList class, a “one size fits all” collection that holds elements of type Object.

In even older versions of Java, programmers used the Vector class for dynamic arrays.

Use the add method to add new elements to an array list.

If you call add and the internal array is full,

If you already know, or have a good guess, how many elements you want to store, call the

That call allocates an internal array of 100 objects. Then, the first 100 calls to add will not involve

You can also pass an initial capacity to the ArrayList constructor: ArrayList<Employee> staff = new ArrayList<>(100);

Allocating an array list as

Note
is not the same as allocating a new array as

There is an important distinction between the capacity of an array list and the size of an array.

What's the distinction?

The

method returns the actual number of elements in the array list.

This is the equivalent of

for an array a.

Once you are reasonably sure that the array list is at its permanent size, you can call

Once you trim the size of an array list, adding new elements will

java.util.ArrayList<T> 1.2

• ArrayList<T>()

• ArrayList<T>(int initialCapacity)

• boolean add(T obj)

Note
• int size()

• void ensureCapacity(int capacity)

Note
• void trimToSize()

5.3.1. Accessing Array List Elements

you use the

methods.

Do not call list.set(i, x) until

Sometimes, you need to add elements in the middle of an array list. Use

Similarly, you can remove an element from the middle of an array list:

Note
But if you store many elements and frequently insert and remove in the middle of a collection, consider using

instead.

You can use

to traverse the contents of an array list:

java.util.ArrayList<T> 1.2

• void set(int index, T obj)

• T get(int index)

• void add(int index, T obj)

Note
• T remove(int index)

5.3.2. Compatibility between Typed and Raw Array Lists

In your own code, you will always want to use type parameters for added safety.

In this section, you will see how to interoperate with legacy code that does not use type parameters.

you can tag the variable that receives the cast with the @SuppressWarnings("unchecked") annotation,

5.4. Object Wrappers and Autoboxing

Note
These kinds of classes are usually called wrappers.

The wrapper classes are immutable—you cannot change

Note
They are also final, so you cannot subclass them.

Another Java SE 5.0 innovation makes it easy to add and get array elements. The call list.add(3); is automatically translated to

This conversion is called autoboxing.

when you assign an Integer object to an int value, it is

In most cases, you get the illusion that the primitive types and their wrappers are one and the same. There is just one point in which they differ considerably:

objects—parseInt is a

method.

If you do want to write a method to change numeric parameters, you can use

java.lang.Integer 1.0

• int intValue()

• static String toString(int i)

• static String toString(int i, int radix)

• static int parseInt(String s)

• static int parseInt(String s, int radix)

• static Integer valueOf(String s)

• static Integer valueOf(String s, int radix)

java.text.NumberFormat 1.1

• Number parse(String 

5.5. Methods with a Variable Number of Parameters

public class PrintStream {    public PrintStream printf(String fmt, Object... args) { return format(fmt, args); } } Here, the ellipsis ... is part of the Java code. It denotes that the method can receive an arbitrary number of objects (in addition to the fmt parameter).

The printf method actually receives two parameters:

You can define your own methods with variable parameters, and you can specify any type for the parameters, even a primitive type.

It is legal to pass an array as the last parameter of a method with variable parameters.

5.6. Enumeration Classes

Note
The type defined by this declaration is actually a class. The class has exactly four instances—it is not possible 

You can, if you like, add constructors, methods, and fields to an enumerated type. Of course, the constructors are only invoked when

Note
All enumerated types are subclasses of

They inherit a number of methods from that class. The most useful one is

The converse of toString is the

Each enumerated type has a

that returns an array of all values of the enumeration.

Note
The

method yields the position of an enumerated constant in the enum declaration, counting from zero.

The short program in Listing 5.12 demonstrates how to work with enumerated types.

The Enum class has a type parameter that we have ignored for simplicity. For example, the enumerated type Size actually extends Enum<Size>. The type parameter is used in the compareTo method.

java.lang.Enum<E> 5.0

• static Enum valueOf(Class enumClass, String name)

Note
• String toString()

• int ordinal()

• int compareTo(E other)

5.7. Reflection

The reflection library gives you a very rich and elaborate toolset to write programs that manipulate Java code dynamically.

A program that

is called reflective.

The reflection mechanism is extremely powerful. As the next sections show, you can use it to

Note
it is of interest mainly to tool builders, not application programmers.

5.7.1. The Class Class

While your program is running, the Java runtime system always maintains what is called

Note
This information keeps track of the class to which each object belongs.

Runtime type information is used by the virtual machine to

Note
you can also access this information by working with a special Java class. The class that holds this information is called, somewhat confusingly, Class.

Probably the most commonly used method of Class is

You can obtain a Class object corresponding to a class name by using

A third method for obtaining an object of type Class is a convenient shorthand. If T is any Java type, then T.class is the matching class object. For example:

Note that a Class object really describes a type, which may or may not be a class. For example,

Therefore, you can use the == operator to compare class objects.

The virtual machine manages a unique Class object for each type. Therefore, you can use the == operator to compare class objects.

Another example of a useful method is one that lets you create an instance of a class on the fly. This method is called,

For example,

Note
A combination of forName and newInstance lets you create an object from a class name stored in a string.

5.7.2. A Primer on Catching Exceptions

There are two kinds of exceptions:

With

the compiler checks that you provide a handler.

Place one or more statements that might throw checked exceptions inside a

Then provide the

in the catch clause.

Note
Throwable is the superclass of

Note
You only need to supply an exception handler for

java.lang.Class 1.0

• static Class forName(String className)

• Object newInstance()

java.lang.reflect.Constructor 1.1

Note
• Object newInstance(Object[] args)

Note
java.lang.Throwable 1.0

• void printStackTrace()

5.7.3. Using Reflection to Analyze the Capabilities of Classes

The three classes

in the java.lang.reflect package describe the

of a class, respectively. All three classes have a method called getName

of a class, respectively. All three classes have a method called getName that returns

The Field class has a method getType that

The Field class has a method getType that returns

The Method and Constructor classes have methods to report

Note
type. All three of these classes also have a method called getModifiers that returns

Note
You can then use the static methods in the

class in the java.lang.reflect package to analyze the

You can also use the

to print the modifiers.

The

Note
and

methods of the Class class return arrays of the public

The

and

methods of the Class class return arrays consisting of

What is remarkable about this program is that it can analyze any class that the Java interpreter can load, not just the classes that were available when the program was compiled.

Note
java.lang.Class 1.0

• Field[] getFields() 1.1 • Field[] getDeclaredFields() 1.1

• Method[] getMethods() 1.1 • Method[] getDeclaredMethods() 1.1

• Constructor[] getConstructors() 1.1 • Constructor[] getDeclaredConstructors() 1.1

java.lang.reflect.Field 1.1 java.lang.reflect.Method 1.1 java.lang.reflect.Constructor 1.1 • Class getDeclaringClass()

• Class[] 

Note
• int getModifiers()

• String getName()

• Class[] getParameterTypes()

• Class getReturnType() (in Method classes)

java.lang.reflect.Modifier 1.1

• static String toString(int modifiers)

• static boolean isAbstract(int modifiers) • static boolean isFinal(int modifiers) • static boolean isInterface(int modifiers) • static boolean isNative(int modifiers) • static boolean isPrivate(int modifiers) • static boolean isProtected(int modifiers) • static boolean isPublic(int modifiers) • static boolean isStatic(int modifiers) • static boolean isStrict(int modifiers) • static boolean isSynchronized(int modifiers) • static boolean isVolatile(int modifiers)

Note
5.7.4. Using Reflection to Analyze Objects at Runtime

But reflection lets you look at fields of objects

The key method to achieve this examination is the

method in the

class.

Note
You can only use get to get the values of accessible fields.

The default behavior of the reflection mechanism is to respect Java access control. However, if a Java program is not controlled by a security manager that disallows it, you can override access control. To do this, invoke the

method on a

object.

The

method is a method of the AccessibleObject class, the common super-class of the Field, Method, and Constructor classes.

Note
suppose we want to look at the salary field. That is a double, and in Java, number types are not objects. To handle this, you can either use the

method of the Field class, or you can call get, whereby the reflection mechanism

Note
The call

Note
sets the field represented by f of the object obj to the new value.

You can use this generic toString method to implement the toString methods of your own classes, like this:

java.lang.reflect.AccessibleObject 1.2

• void setAccessible(boolean flag)

• boolean isAccessible()

• static void setAccessible(AccessibleObject[]

java.lang.Class 1.1

• Field getField(String name) • Field[] getFields()

• Field getDeclaredField(String name) • Field[] getDeclaredFields()

java.lang.reflect.Field 1.1

• Object get(Object obj)

Note
• void set(Object obj, Object newValue)

5.7.5. Using Reflection to Write Generic Array Code

The

class in the

allows you to create arrays dynamically.

Note
This is used, for example, in the implementation of

method in the

Note
class.

a Java array remembers

It is legal to cast an

Employee[] temporarily to an Object[] array and then cast it back, but an array that

Note
started its life as an Object[] array can never be

It is legal to cast an Employee[] temporarily to an Object[] array and then cast it back, but an array that started its life as an Object[] array can never be

To write this kind of generic array code, we need to be able to

For this, we need

in the java.lang.reflect package.

The key is the

method of

You must supply

as parameters to this method.

We obtain the length by calling

Note
java.lang.reflect.Array 1.1

• static Object get(Object array, int index) • static xxx getXxx(Object array, int index)

(xxx is one of the primitive types

• static void set(Object array, int index, Object newValue)

• static set Xxx(Object array, int index, xxx newValue)

• static int getLength(Object array)

• static Object newInstance(Class componentType, int length) • static Object

newInstance(Class componentType, int[] lengths)

5.7.6. Invoking Arbitrary Methods

Note
the reflection mechanism allows you to call arbitrary methods.

the Method class has an

method that lets you call the method that is wrapped in the current Method object. The signature for the invoke method is

The first parameter is the

and the remaining objects provide

For a static method, the first parameter is

can set it to

For example, if m1 represents the getName method of the Employee class, the following code shows how you can call it:

If the return type is a primitive type, the invoke method will return the

How do you obtain a Method object?

you must also supply the parameter types of the desired method. The signature of getMethod is

Note
Or, you can call the getMethod method of the Class class.

you must also supply the parameter types of the desired method. The signature of getMethod is

What happens if you invoke a method with the wrong parameters?

Moreover, code that uses reflection to get at method pointers is significantly slower than code that simply calls methods directly.

Note
For that reason, we suggest that you use Method objects in your own programs only when absolutely necessary.

Note
java.lang.reflect.Method 1.1

• public Object invoke(Object implicitParameter, Object[] explicitParameters)

5.8. Design Hints for Inheritance

some hints that we have found useful when using inheritance.

Note
The first technique, called interfaces, is a way of describing

Note
A class can implement one or more interfaces.

Note
6.1. Interfaces

an interface is not a class but a

As of Java SE 5.0, the Comparable interface has been enhanced to be a generic type.

All methods of an interface are automatically public.

What is more important, however, is what interfaces cannot supply.

Note
Interfaces never have instance fields, and the methods are never implemented in the interface.

Tue Feb 19 08:56:57 GMT 2019

To make a class implement an interface, you carry out two steps:

To declare that a class implements an interface, use the implements keyword:

To declare that a class implements an interface, use the

In the interface declaration, the compareTo method was not declared public because

However, when implementing the interface, you must declare the method as public. Otherwise, the compiler assumes that the method has

visibility—the default for a class.

As of Java SE 5.0, we can do a little better. We’ll implement the Comparable<Employee> interface type instead.

The compareTo method of the Comparable interface returns an integer. If the objects are not equal, it does not matter what negative or positive value you return. This flexibility can be useful when you are comparing integer fields. For example,

The reason for interfaces is that the Java programming language is

java.lang.Comparable<T> 1.0 • int compareTo(T

java.lang.Comparable<T> 1.0

• int compareTo(T other)

java.util.Arrays 1.2

• static void sort(Object[] a)

java.lang.Integer 7

• static int compare(int x, int y)

java.lang.Double 7

• static int compare(double x, double y)

If subclasses have different notions of comparison, then you should outlaw comparison of objects that belong to different classes. Each compareTo method should start out with the test if (getClass() != other.getClass()) throw new ClassCastException();

If there is a common algorithm for comparing subclass objects, simply provide a single compareTo method in the superclass and declare it as final.

6.1.1. Properties of Interfaces

However, even though you can’t construct interface objects, you can still declare interface variables.

An interface variable must refer to

just as you use

to check whether an object is of a specific class, you can use

to check whether an object implements an interface:

Just as you can build hierarchies of classes, you can

interfaces.

Although you cannot put

in an interface, you can supply constants in them.

Just as methods in an interface are automatically

fields are always

Some interfaces define just constants and no methods.

While each class can have only one superclass, classes can implement multiple interfaces.

Use

to separate the interfaces that describe the characteristics that you want to supply.

6.1.2. Interfaces and Abstract Classes

If you read the section about abstract classes in Chapter 5, you may wonder why the designers of the Java programming language bothered with introducing the concept of interfaces. Why can’t Comparable simply be an abstract class:

6.2. Object Cloning

The clone method is a protected method of Object, which means that your code

Only the

class can clone Employee objects. There is a reason for this restriction.

Does it matter if the copy is shallow? It depends.

Quite frequently, however, subobjects are mutable, and you must redefine the clone method to make a

For every class, you need to decide whether

The third option is actually the default. To choose either the first or the second option, a class must

A subclass can call a protected clone method only to clone

You must redefine clone to be

In this case, the appearance of the Cloneable interface has nothing to do with the normal use of interfaces.

The Cloneable interface is one of a handful of tagging interfaces that Java provides. (Some programmers call them marker interfaces.)

A tagging interface has no

its only purpose is to

Even if the default (shallow copy) implementation of clone is adequate, you still need to implement the

redefine clone to be

and call super.clone().

public Employee clone() {    try    {       return (Employee) super.clone();    }    catch (CloneNotSupportedException e) { return null; }    // this won't happen, since we are Cloneable } This is appropriate for final classes. Otherwise, it is a good idea to leave the throws specifier in place. That gives subclasses the option of

You have to be careful about cloning of subclasses. For example, once you have defined the clone method for the Employee class, anyone can use it to clone Manager objects. Can the Employee clone method do the job? It depends on

All array types have a clone method that is public, not protected. You can use it to make a new array that contains copies of all elements.

6.3. Interfaces and Callbacks

A common pattern in programming is the callback pattern. In this pattern, you want to specify

whenever

The javax.swing package contains a Timer class that is useful if you want to be notified whenever a time interval has elapsed.

Whenever you would use a function pointer in C++, you should consider using an interface in Java.

javax.swing.JOptionPane 1.2

• static void

showMessageDialog(Component parent, Object message)

javax.swing.Timer 1.2

• Timer(int interval, ActionListener listener)

• void start()

• void stop()

java.awt.Toolkit 1.0

• static Toolkit getDefaultToolkit()

• void beep()

6.4. Inner Classes

An inner class is a class that is

Why would you want to do that? There are three reasons:

6.4.1. Use of an Inner Class to Access Object State

We refactor the TimerTest example and extract a TalkingClock class.

For this to work, an object of an inner class always gets an implicit reference to the object that created it.

This reference is invisible in the definition of the inner class.

We could have declared the TimePrinter class as private. Then only

would be able to construct

Only inner classes can be private.

6.4.2. Special Syntax Rules for Inner Classes

The expression

denotes the outer class reference.

Conversely, you can write the inner object constructor more explicitly, using the syntax

the outer class reference of the newly constructed TimePrinter object is set to the

reference of the method that creates the inner class object. This is the most common case.

However, it is also possible to set the outer class reference to another object by explicitly naming it.

6.4.3. Are Inner Classes Useful? Actually Necessary? Secure?

it is worth noting that inner classes are a phenomenon of the compiler, not the virtual machine. Inner classes are translated into regular class files with $ (dollar signs) delimiting outer and inner class names, and the virtual machine does not have any special knowledge about them.

The synthesized constructors and methods can get quite convoluted.

6.4.4. Local Inner Classes

In a situation like this, you can define the class locally in a single method.

Local classes are never declared with an access specifier

Their scope is always restricted to the block in which they are declared.

Local classes have one great advantage:

6.4.5. Accessing final Variables from Outer Methods

Local classes have another advantage over other inner classes.

they can even access

However, those

must be declared

The final keyword can be applied to

In all cases it means the same thing:

However, you don’t have to

when you define it.

Since ActionListener is an interface, how come it is instantiated here 

A final variable that isn’t initialized when it is defined is often called a

6.4.6. Anonymous Inner Classes

When using local inner classes, you can often go a step further. If you want to make only a single object of this class, you don’t even need to give the class a name. Such a class is called an anonymous inner class.

In general, the syntax is

Here, SuperType can be an interface, such as ActionListener; then, the inner class implements that interface. SuperType can also be a class; then, the inner class extends that class.

An anonymous inner class cannot have constructors because

In particular, whenever an inner class implements an interface, it cannot have

Nevertheless, you must supply a set of parentheses as in

If the closing parenthesis of the construction parameter list is followed by

then an anonymous inner class is being defined.

The following trick, called double brace initialization, takes advantage of the inner class syntax.

If you don’t need the array list again, it would be nice to make it anonymous. But then how can you add the elements? Here is how: invite(new ArrayList<String>() {{ add("Harry"); add("Tony"); }})

Note the double braces. The outer braces make

Note the double braces. The outer braces make an

The inner braces are an

It is often convenient to make an anonymous subclass that is almost, but not quite, like its superclass. But you need to be careful with the

method.

When you produce logging or debugging messages, you often want to include the name of the current class, such as

Here, new Object(){} makes an anonymous object of an anonymous subclass of Object, and getEnclosingClass gets its enclosing class—that is, the class containing the static method.

6.4.7. Static Inner Classes

You can suppress the generation of that reference by declaring the inner class static.

Of course, only

can be declared static.

A static inner class is exactly like any other inner class, except that

Use a static inner class whenever the inner class

6.5. Proxies

You can use a proxy to create, at runtime, new classes that implement a given set of interfaces.

This is not a common situation for application programmers, and you should feel free to skip this section if you are not interested in advanced wizardry. However, for certain systems programming applications, the flexibility that proxies offer can be very important.

To construct an actual class, you can simply use the newInstance method or use reflection to find a constructor.

The proxy class can create brand-new classes at runtime. Such a proxy class implements the

Note
Instead, you must supply an invocation handler.

Instead, you must supply an invocation handler. An invocation handler is

6.5.1. Properties of Proxy Classes

Remember that proxy classes are created on the fly in a running program.

All proxy classes extend the class Proxy.

All proxy classes extend the class

A proxy class has only one instance field—the

which is defined in the

Any additional data required to carry out the proxy objects’ tasks must be stored in

All proxy classes override the

methods of the Object class.

Like all proxy methods, these methods simply call

on the invocation handler.

Proxy class in Oracle’s virtual machine generates class names that begin with the string

There is only one proxy class for a particular class loader and ordered set of interfaces. That is, if you call the newProxyInstance method twice with the same class loader and interface array, you get two objects of the same class. You can also obtain that class with the

method:

A proxy class is always

If all interfaces that the proxy class implements are public, the proxy class does not belong to

Note
Otherwise, all non-public interfaces must belong to

and the proxy class will also belong to

You can test whether a particular Class object represents a proxy class by calling the

java.lang.reflect.InvocationHandler 1.3

• Object invoke(Object proxy, Method method, Object[] args)

java.lang.reflect.Proxy 1.3

• static Class getProxyClass(ClassLoader loader, Class[] interfaces)

Note
• static Object newProxyInstance(ClassLoader loader, Class[] interfaces, InvocationHandler handler)

• static boolean isProxyClass(Class c) returns true if c is a proxy class.

All objects that are instances of the same class share a family resemblance by supporting the same
